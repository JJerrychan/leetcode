[TOC]

## Video Solution

---

<div> 
 <div class="video-container"> 
  <iframe src="https://player.vimeo.com/video/724348592?texttrack=en-x-autogenerated" frameborder="0" allow="autoplay; fullscreen"></iframe> 
 </div> 
</div>

## Solution

---

#### Approach 1: Brute Force

One of the most straightforward approaches would be iterating through the entire array using a nested loop to examine that, for each element  `a` in `time`, whether there is another element `b` such that `(a + b) % 60 == 0`. Note that this approach might be too brutal to pass an interview.

<iframe src="https://leetcode.com/playground/keJDY6pR/shared" frameBorder="0" width="100%" height="310" name="keJDY6pR"></iframe>

**Complexity Analysis**

* Time complexity: $\mathcal{O}(n^2)$, when $n$ is the length of the input array. For each item in `time`, we iterate through the rest of the array to find a qualified complement taking $\mathcal{O}(n)$ time.
* Space complexity: $\mathcal{O}(1)$.

<br />

---

#### Approach 2: Use an Array to Store Frequencies

**Intuition**

Let's dive deep into the condition `(time[i] + time[j]) % 60 == 0` to examine the relation between `time[i]` and `time[j]`. Assuming that `a` and `b` are two elements in the input array `time`, we have:

<div align="center">
  $$ (a+b)\space \% \space60=0 \\ \Downarrow \\ ((a \space \% \space 60)+(b \space \% \space 60))\space \% \space 60=0 \\ \Downarrow \\ \text{Therefore, either }\begin{cases} a \space \% \space60 &amp;= 0\\ b \space \% \space60 &amp;= 0 \end{cases} \text{, or } (a\space\%\space60)+(b\space\%\space60)=60 \\ $$ 
</div>

You can learn more about the modulo operation [here](https://en.wikipedia.org/wiki/Modulo_operation#Properties_(identities)).

Hence, all we need would be finding the pairs of elements in `time` so they meet these conditions.

**Algorithm**

We would iterate through the input array `time` and for each element `a`, we want to know the number of elements `b` such that:

1. $b \space\%\space 60=0$, $ \space \text{if } a \space \% \space 60=0$
2. $b \space \% \space 60=60-a \space\% \space60$, $ \space \text{if }  a\space\% \space 60\neq0$

We can use Approach 1 to implement this logic by repeatedly examining the rest of `time` again and again for each element `a`. However, we are able to improve the time complexity by consuming more space - we can store the frequencies of the remainder `a % 60`, so that we can find the number of the complements in $\mathcal{O}(1)$ time.

!?!../Documents/1010_Pairs_of_Songs_With_Total_Durations_Divisible_by_60.json:681,277!?!

We would initiate an array `remainders` with size $60$ to record the frequencies of each remainder - as the range of remainders is $[0,59] $.  Then we can loop through the array once and for each element `a` we would:

1. if $a \space \% \space 60=0$, add `remainders[0]` to the result; else, add `remainders[60 - a % 60]` to the result;
2. update `remainders[a % 60]`.

<iframe src="https://leetcode.com/playground/VmxQZVfS/shared" frameBorder="0" width="100%" height="310" name="VmxQZVfS"></iframe>

**Complexity Analysis**

* Time complexity: $\mathcal{O}(n)$, when $n$ is the length of the input array, because we would visit each element in `time` once.
* Space complexity: $\mathcal{O}(1)$, because the size of the array `remainders` is fixed with $60$.

<br /> ---

